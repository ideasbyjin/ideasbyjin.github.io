<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Numba in action! | Read between the rows</title><meta name=keywords content><meta name=description content="Accelerate your Numpy code with numba"><meta name=author content><link rel=canonical href=/post/2021-01-30-numba/><link href=/assets/css/stylesheet.min.54720d48c4fa0c4ebe8555f04b9fc5b856112ec49cafef19cb385e89661150b7.css integrity="sha256-VHINSMT6DE6+hVXwS5/FuFYRLsScr+8ZyzheiWYRULc=" rel="preload stylesheet" as=style><link rel=icon href=favicon.ico><link rel=icon type=image/png sizes=16x16 href=favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=favicon-32x32.png><link rel=apple-touch-icon href=apple-touch-icon.png><link rel=mask-icon href=safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.80.0"><script>MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$'],['\\[','\\]']],processEscapes:true,processEnvironments:true},options:{skipHtmlTags:['script','noscript','style','textarea','pre']}};window.addEventListener('load',(event)=>{document.querySelectorAll("mjx-container").forEach(function(x){x.parentElement.classList+='has-jax'})});</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><meta property="og:title" content="Numba in action!"><meta property="og:description" content="Accelerate your Numpy code with numba"><meta property="og:type" content="article"><meta property="og:url" content="/post/2021-01-30-numba/"><meta property="article:published_time" content="2021-01-30T00:00:00+00:00"><meta property="article:modified_time" content="2021-01-30T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Numba in action!"><meta name=twitter:description content="Accelerate your Numpy code with numba"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Numba in action!","name":"Numba in action!","description":"Accelerate your Numpy code with numba","keywords":[],"articleBody":"I’ve discovered numba a few months ago, and haven’t looked back since. I wouldn’t consider myself a numba expert as there’s lots of capabilities I’m still wrapping my head around (e.g. @overload decorators), but there’s some use cases where Numba could be really useful. If you find you’re doing a lot of numpy for your work, this is for you!\nIf you have:\n 30 seconds: @numba.jit(nopython=True) your functions if it’s purely numpy driven. Can be a bit of effort though. 5 minutes: read on.  Okay, what is numba, exactly? Numba is a “just-in-time” (JIT) compiler, which essentially means that a function you create will be compiled and can run independently of the Python interpreter. Simply, if your code involves lots of numpy and math, chances are, you can speed it up even more.\nThat sounds great, but… Anecdotally speaking I’ve seen about 100-200x performance gains for some of the functions I’ve written with numba. The beauty of it is that it involves almost no work, provided that the code is mostly already in numpy, and that numba is compatible with your implementation. This is the catch that I think the 5-minute numba docs don’t cover.\nnumba is heavily typed and has specific implementations and signatures of numpy functions. In other words, you might have found that you can “get away” with calling numpy in specific ways in “normal” Python, but upon compiling with numba, you will come to some very surprising errors. You could argue that this is helpful though.\nExample The example we’re going to cover is the RAPDF function from Samudrala and Moult. RAPDF represents a sort of log odds ratio that two atoms of types $i$ and $j$ come into contact in a specific distance bin $d$:\n$$\\textrm{RAPDF} = -log\\left(\\dfrac{\\dfrac{n(d_{ij})}{\\sum_d n(d_{ij})}}{\\dfrac{\\sum_{ij} n(d_{ij})}{\\sum_d \\sum_{ij} n(d_{ij})}}\\right) $$\nThis is typically the kind of data where RAPDF would be applied to; I’ve simplified the contacts to amino acids rather than atoms, but in practice, it would involve the same computation:\nimport pandas as pd # this is just a randomly generated contact map # each cell shows number of contacts between 2 amino acids # at a given distance bin (e.g. 0-3 Angstroms) df = pd.read_csv(\"contact_map.tsv\", sep='\\t', index_col = 0) df.head(5) .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; }  If you’re curious:, the top fraction in the numerator represents the number of contacts between types $$i$$ and $$j$$ in distance bin $$d$$, divided by the total number of contacts between types $$i$$ and $$j$$ across all distance bins. This is then divided by the bottom fraction, where the number of contacts between all atom types at a specific distance bin $$d$$ is divided by all contacts across all distance bins.\nYou may have noticed some 0s in the data; since we’re going to compute a log later, we’ll add a pseudocount of 0.0001.\ndf = df+1e-4 df.head(5) .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; }  Now to the code We can code RAPDF as so:\nimport numpy as np def rapdf(contact_map: np.ndarray): all_contact_d = np.sum(contact_map, axis=0) all_contact_all_d = np.sum(contact_map) # this is constant per distance bin, so only calculate once! denominator = all_contact_d / all_contact_all_d scores = np.zeros(contact_map.shape) for i, row in enumerate(contact_map): # this just ensures we don't divide by 0 rowsum = max(row.sum(), 1) for j, cell in enumerate(row): numerator = (cell/rowsum) scores[i][j] = -np.log(numerator/denominator[j]).round(2) return scores Now we can see it in action:\nfrom time import time t1 = time() scores = rapdf(df.values) t2 = time() print(scores, \"This took {} miroseconds\".format((t2-t1)*(10**6))) [[-0.07 -0.23 0.65 -0.82 0.2 10.55] [-0.84 -0.19 0. 0.73 10.55 0. ] [-0.52 0.64 1.3 10.55 -0.54 -0.65] ... [10.73 0.48 -0.4 -0.62 -0.59 1.54] [-0.14 1.71 -0.27 -0.49 -0.57 10.88] [-0.14 -0.08 0.98 -0.24 0.24 -0.27]] This took 13474.225997924805 miroseconds  Cool, we can also use the timeit magic function to do this with more runs:\n%timeit rapdf(df.values) 7.64 ms ± 186 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)  ~7.8ms (or about 7800 microseconds) isn’t bad, but this is where numba will shine. To start, we just need to apply a decorator, @numba.jit(nopython=True). This tells numba to compile the function in nopython mode, meaning maximum performance gains; otherwise, without the flag, I’ve found that the performance gains I had gotten wasn’t really worth the effort.\nimport numba # This is a decorator that tells numba to compile this function in \"no python mode\". @numba.jit(nopython=True) def rapdf(contact_map: np.ndarray): all_contact_d = np.sum(contact_map, axis=0) all_contact_all_d = np.sum(contact_map) # this is constant per distance bin, so only calculate once! denominator = all_contact_d / all_contact_all_d scores = np.zeros(contact_map.shape) for i, row in enumerate(contact_map): # this just ensures we don't divide by 0 rowsum = max(row.sum(), 1) for j, cell in enumerate(row): numerator = (cell/rowsum) scores[i][j] = -np.log(numerator/denominator[j]).round(2) return scores To start with, let’s use the exact same definition as above; then we can call rapdf again:\nt1 = time() scores = rapdf(df.values) t2 = time() print(scores, \"This took {} miroseconds\".format((t2-t1)*(10**6))) ... TypingError: Failed in nopython mode pipeline (step: nopython frontend) Unknown attribute 'round' of type float64 File \"\", line 22: def rapdf(contact_map: np.ndarray): numerator = (cell/rowsum) scores[i][j] = -np.log(numerator/denominator[j]).round(2) ^  This was half-expected. From experience, there will always be something that numba isn’t compatible with; in this case, the round operation. We can “get rid of it” by doing a trick:\n@numba.jit(nopython=True) def rapdf(contact_map: np.ndarray): # The rest of the function has remained identical ... for j, cell in enumerate(row): numerator = (cell/rowsum) # notice where the round operator has gone now! scores[i][j] = np.round(-np.log(numerator/denominator[j]), 2) return scores And now, will it run?\nt1 = time() scores = rapdf(df.values) t2 = time() print(scores, \"This took {} miroseconds\".format((t2-t1)*(10**6))) [[-0.07 -0.23 0.65 -0.82 0.2 10.55] [-0.84 -0.19 0. 0.73 10.55 0. ] [-0.52 0.64 1.3 10.55 -0.54 -0.65] ... [10.73 0.48 -0.4 -0.62 -0.59 1.54] [-0.14 1.71 -0.27 -0.49 -0.57 10.88] [-0.14 -0.08 0.98 -0.24 0.24 -0.27]] This took 1207432.9853057861 miroseconds  Now it works! You might now be thinking, wait a minute, this was actually slower than before! Hold on a minute. The reason for this is that numba had to compile your function the first time you call it. This is where most of the time has gone in. In fact, if you now call rapdf again, you’ll see:\nt1 = time() scores = rapdf(df.values) t2 = time() print(scores, \"This took {} miroseconds\".format((t2-t1)*(10**6))) [[-0.07 -0.23 0.65 -0.82 0.2 10.55] [-0.84 -0.19 0. 0.73 10.55 0. ] [-0.52 0.64 1.3 10.55 -0.54 -0.65] ... [10.73 0.48 -0.4 -0.62 -0.59 1.54] [-0.14 1.71 -0.27 -0.49 -0.57 10.88] [-0.14 -0.08 0.98 -0.24 0.24 -0.27]] This took 232.93495178222656 miroseconds  And if we do this over several runs:\n%timeit rapdf(df.values) 28.1 µs ± 341 ns per loop (mean ± std. dev. of 7 runs, 10000 loops each)  Now look at that! It’s shrunk down to 28 microseconds in comparison to the 7 miliseconds we had before. That’s equivalent to a 250-fold speed up. You can imagine that if you had code that you’d call over and over again, this is where numba could be so useful.\n","wordCount":"1192","inLanguage":"en","datePublished":"2021-01-30T00:00:00Z","dateModified":"2021-01-30T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"/post/2021-01-30-numba/"},"publisher":{"@type":"Organization","name":"Read between the rows","logo":{"@type":"ImageObject","url":"favicon.ico"}}}</script></head><body id=top><script>if(localStorage.getItem("pref-theme")==="dark"){document.body.classList.add('dark');}</script><noscript><style type=text/css>.theme-toggle,.top-link{display:none}</style></noscript><header class=header><nav class=nav><div class=logo><a href accesskey=h title="Read between the rows (Alt + H)">Read between the rows</a>
<span class=logo-switches><a id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></a></span></div><ul id=menu onscroll=menu_on_scroll()><li><a href=/about title=about><span>about</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Numba in action!</h1><div class=post-meta>January 30, 2021&nbsp;·&nbsp;6 min</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><div class=details>Table of Contents</div></summary><div class=inner><ul><li><a href=#okay-what-is-numba-exactly aria-label="Okay, what is numba, exactly?">Okay, what is numba, exactly?</a><ul><li><a href=#that-sounds-great-but aria-label="That sounds great, but&amp;hellip;">That sounds great, but&mldr;</a></li><li><a href=#example aria-label=Example>Example</a></li><li><a href=#now-to-the-code aria-label="Now to the code">Now to the code</a></li></ul></li></ul></div></details></div><div class=post-content><p>I&rsquo;ve discovered <code>numba</code> a few months ago, and haven&rsquo;t looked back since. I wouldn&rsquo;t consider myself a <code>numba</code> expert as there&rsquo;s lots of capabilities I&rsquo;m still wrapping my head around (e.g. <code>@overload</code> decorators), but there&rsquo;s some use cases where Numba could be really useful. If you find you&rsquo;re doing a lot of <code>numpy</code> for your work, this is for you!</p><p>If you have:</p><ul><li><strong>30 seconds</strong>: <code>@numba.jit(nopython=True)</code> your functions if it&rsquo;s purely numpy driven. Can be a bit of effort though.</li><li><strong>5 minutes</strong>: read on.</li></ul><h2 id=okay-what-is-numba-exactly>Okay, what is numba, exactly?<a hidden class=anchor aria-hidden=true href=#okay-what-is-numba-exactly>#</a></h2><p>Numba is a &ldquo;just-in-time&rdquo; (JIT) compiler, which essentially means that a function you create will be compiled and can run independently of the Python interpreter. Simply, if your code involves lots of <code>numpy</code> and math, chances are, you can speed it up <em>even</em> more.</p><h3 id=that-sounds-great-but>That sounds great, but&mldr;<a hidden class=anchor aria-hidden=true href=#that-sounds-great-but>#</a></h3><p>Anecdotally speaking I&rsquo;ve seen about 100-200x performance gains for some of the functions I&rsquo;ve written with <code>numba</code>. The beauty of it is that it involves almost no work, provided that the code is mostly already in <code>numpy</code>, and that <code>numba</code> is compatible with your implementation. This is the catch that I think the 5-minute <code>numba</code> docs don&rsquo;t cover.</p><p><code>numba</code> is heavily typed and has specific implementations and signatures of <code>numpy</code> functions. In other words, you might have found that you can &ldquo;get away&rdquo; with calling <code>numpy</code> in specific ways in &ldquo;normal&rdquo; Python, but upon compiling with <code>numba</code>, you will come to some very surprising errors. You could argue that this is helpful though.</p><h3 id=example>Example<a hidden class=anchor aria-hidden=true href=#example>#</a></h3><p>The example we&rsquo;re going to cover is the RAPDF function from <a href=https://pubmed.ncbi.nlm.nih.gov/9480776/>Samudrala and Moult</a>. RAPDF represents a sort of log odds ratio that two atoms of types $i$ and $j$ come into contact in a specific distance bin $d$:</p><p>$$\textrm{RAPDF} = -log\left(\dfrac{\dfrac{n(d_{ij})}{\sum_d n(d_{ij})}}{\dfrac{\sum_{ij} n(d_{ij})}{\sum_d \sum_{ij} n(d_{ij})}}\right) $$</p><p>This is typically the kind of data where RAPDF would be applied to; I&rsquo;ve simplified the contacts to amino acids rather than atoms, but in practice, it would involve the same computation:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#f92672>import</span> pandas <span style=color:#f92672>as</span> pd

<span style=color:#75715e># this is just a randomly generated contact map</span>
<span style=color:#75715e># each cell shows number of contacts between 2 amino acids</span>
<span style=color:#75715e># at a given distance bin (e.g. 0-3 Angstroms)</span>
df <span style=color:#f92672>=</span> pd<span style=color:#f92672>.</span>read_csv(<span style=color:#e6db74>&#34;contact_map.tsv&#34;</span>, sep<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;</span><span style=color:#ae81ff>\t</span><span style=color:#e6db74>&#39;</span>, index_col <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>)
df<span style=color:#f92672>.</span>head(<span style=color:#ae81ff>5</span>)
</code></pre></div><pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
</code></pre><p></p><p><strong>If you&rsquo;re curious</strong>:, the top fraction in the numerator represents the number of contacts between types $$i$$ and $$j$$
in distance bin $$d$$, divided by the total number of contacts between types $$i$$ and $$j$$ across all distance bins.
This is then divided by the bottom fraction, where the number of contacts between all atom types at a specific distance
bin $$d$$ is divided by all contacts across all distance bins.</p><p>You may have noticed some 0s in the data; since we&rsquo;re going to compute a log later, we&rsquo;ll add a pseudocount of 0.0001.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>df <span style=color:#f92672>=</span> df<span style=color:#f92672>+</span><span style=color:#ae81ff>1e-4</span>
df<span style=color:#f92672>.</span>head(<span style=color:#ae81ff>5</span>)
</code></pre></div><pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
</code></pre><p></p><h3 id=now-to-the-code>Now to the code<a hidden class=anchor aria-hidden=true href=#now-to-the-code>#</a></h3><p>We can code RAPDF as so:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#f92672>import</span> numpy <span style=color:#f92672>as</span> np

<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>rapdf</span>(contact_map: np<span style=color:#f92672>.</span>ndarray):
    
    all_contact_d <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>sum(contact_map, axis<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>)
    all_contact_all_d <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>sum(contact_map)
    
    <span style=color:#75715e># this is constant per distance bin, so only calculate once!</span>
    denominator <span style=color:#f92672>=</span> all_contact_d <span style=color:#f92672>/</span> all_contact_all_d
    
    scores <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>zeros(contact_map<span style=color:#f92672>.</span>shape)
    
    <span style=color:#66d9ef>for</span> i, row <span style=color:#f92672>in</span> enumerate(contact_map):
        
        <span style=color:#75715e># this just ensures we don&#39;t divide by 0</span>
        rowsum <span style=color:#f92672>=</span> max(row<span style=color:#f92672>.</span>sum(), <span style=color:#ae81ff>1</span>)
        
        <span style=color:#66d9ef>for</span> j, cell <span style=color:#f92672>in</span> enumerate(row):
            
            numerator <span style=color:#f92672>=</span> (cell<span style=color:#f92672>/</span>rowsum)
            scores[i][j] <span style=color:#f92672>=</span> <span style=color:#f92672>-</span>np<span style=color:#f92672>.</span>log(numerator<span style=color:#f92672>/</span>denominator[j])<span style=color:#f92672>.</span>round(<span style=color:#ae81ff>2</span>)
    
    <span style=color:#66d9ef>return</span> scores
</code></pre></div><p>Now we can see it in action:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#f92672>from</span> time <span style=color:#f92672>import</span> time

t1 <span style=color:#f92672>=</span> time()
scores <span style=color:#f92672>=</span> rapdf(df<span style=color:#f92672>.</span>values)
t2 <span style=color:#f92672>=</span> time()

<span style=color:#66d9ef>print</span>(scores, <span style=color:#e6db74>&#34;This took {} miroseconds&#34;</span><span style=color:#f92672>.</span>format((t2<span style=color:#f92672>-</span>t1)<span style=color:#f92672>*</span>(<span style=color:#ae81ff>10</span><span style=color:#f92672>**</span><span style=color:#ae81ff>6</span>)))
</code></pre></div><pre><code>[[-0.07 -0.23  0.65 -0.82  0.2  10.55]
 [-0.84 -0.19  0.    0.73 10.55  0.  ]
 [-0.52  0.64  1.3  10.55 -0.54 -0.65]
 ...
 [10.73  0.48 -0.4  -0.62 -0.59  1.54]
 [-0.14  1.71 -0.27 -0.49 -0.57 10.88]
 [-0.14 -0.08  0.98 -0.24  0.24 -0.27]] This took 13474.225997924805 miroseconds
</code></pre><p>Cool, we can also use the <code>timeit</code> magic function to do this with more runs:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#f92672>%</span>timeit rapdf(df<span style=color:#f92672>.</span>values)
</code></pre></div><pre><code>7.64 ms ± 186 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
</code></pre><p>~7.8ms (or about 7800 microseconds) isn&rsquo;t bad, but this is where <code>numba</code> will shine. To start, we just need to apply a decorator, <code>@numba.jit(nopython=True)</code>. This tells <code>numba</code> to compile the function in nopython mode, meaning maximum performance gains; otherwise, without the flag, I&rsquo;ve found that the performance gains I had gotten wasn&rsquo;t really worth the effort.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#f92672>import</span> numba 
<span style=color:#75715e># This is a decorator that tells numba to compile this function in &#34;no python mode&#34;.</span>
<span style=color:#a6e22e>@numba.jit</span>(nopython<span style=color:#f92672>=</span>True)
<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>rapdf</span>(contact_map: np<span style=color:#f92672>.</span>ndarray):
    
    all_contact_d <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>sum(contact_map, axis<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>)
    all_contact_all_d <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>sum(contact_map)
    
    <span style=color:#75715e># this is constant per distance bin, so only calculate once!</span>
    denominator <span style=color:#f92672>=</span> all_contact_d <span style=color:#f92672>/</span> all_contact_all_d
    
    scores <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>zeros(contact_map<span style=color:#f92672>.</span>shape)
    
    <span style=color:#66d9ef>for</span> i, row <span style=color:#f92672>in</span> enumerate(contact_map):
        
        <span style=color:#75715e># this just ensures we don&#39;t divide by 0</span>
        rowsum <span style=color:#f92672>=</span> max(row<span style=color:#f92672>.</span>sum(), <span style=color:#ae81ff>1</span>)
        
        <span style=color:#66d9ef>for</span> j, cell <span style=color:#f92672>in</span> enumerate(row):
            
            numerator <span style=color:#f92672>=</span> (cell<span style=color:#f92672>/</span>rowsum)
            scores[i][j] <span style=color:#f92672>=</span> <span style=color:#f92672>-</span>np<span style=color:#f92672>.</span>log(numerator<span style=color:#f92672>/</span>denominator[j])<span style=color:#f92672>.</span>round(<span style=color:#ae81ff>2</span>)
    
    <span style=color:#66d9ef>return</span> scores
</code></pre></div><p>To start with, let&rsquo;s use the <em>exact</em> same definition as above; then we can call rapdf again:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>t1 <span style=color:#f92672>=</span> time()
scores <span style=color:#f92672>=</span> rapdf(df<span style=color:#f92672>.</span>values)
t2 <span style=color:#f92672>=</span> time()

<span style=color:#66d9ef>print</span>(scores, <span style=color:#e6db74>&#34;This took {} miroseconds&#34;</span><span style=color:#f92672>.</span>format((t2<span style=color:#f92672>-</span>t1)<span style=color:#f92672>*</span>(<span style=color:#ae81ff>10</span><span style=color:#f92672>**</span><span style=color:#ae81ff>6</span>)))
</code></pre></div><pre><code>...

TypingError: Failed in nopython mode pipeline (step: nopython frontend)
Unknown attribute 'round' of type float64

File &quot;&lt;ipython-input-6-e7160609fabf&gt;&quot;, line 22:
def rapdf(contact_map: np.ndarray):
    &lt;source elided&gt;
            numerator = (cell/rowsum)
            scores[i][j] = -np.log(numerator/denominator[j]).round(2)
            ^
</code></pre><p>This was half-expected. From experience, there will always be something that <code>numba</code> isn&rsquo;t compatible with; in this case, the <code>round</code> operation. We can &ldquo;get rid of it&rdquo; by doing a trick:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#a6e22e>@numba.jit</span>(nopython<span style=color:#f92672>=</span>True)
<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>rapdf</span>(contact_map: np<span style=color:#f92672>.</span>ndarray):
    <span style=color:#75715e># The rest of the function has remained identical</span>
        <span style=color:#f92672>...</span>     
        <span style=color:#66d9ef>for</span> j, cell <span style=color:#f92672>in</span> enumerate(row):
            
            numerator <span style=color:#f92672>=</span> (cell<span style=color:#f92672>/</span>rowsum)
            
            <span style=color:#75715e># notice where the round operator has gone now!</span>
            scores[i][j] <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>round(<span style=color:#f92672>-</span>np<span style=color:#f92672>.</span>log(numerator<span style=color:#f92672>/</span>denominator[j]), <span style=color:#ae81ff>2</span>)
    
    <span style=color:#66d9ef>return</span> scores
</code></pre></div><p>And now, will it run?</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>t1 <span style=color:#f92672>=</span> time()
scores <span style=color:#f92672>=</span> rapdf(df<span style=color:#f92672>.</span>values)
t2 <span style=color:#f92672>=</span> time()

<span style=color:#66d9ef>print</span>(scores, <span style=color:#e6db74>&#34;This took {} miroseconds&#34;</span><span style=color:#f92672>.</span>format((t2<span style=color:#f92672>-</span>t1)<span style=color:#f92672>*</span>(<span style=color:#ae81ff>10</span><span style=color:#f92672>**</span><span style=color:#ae81ff>6</span>)))
</code></pre></div><pre><code>[[-0.07 -0.23  0.65 -0.82  0.2  10.55]
 [-0.84 -0.19  0.    0.73 10.55  0.  ]
 [-0.52  0.64  1.3  10.55 -0.54 -0.65]
 ...
 [10.73  0.48 -0.4  -0.62 -0.59  1.54]
 [-0.14  1.71 -0.27 -0.49 -0.57 10.88]
 [-0.14 -0.08  0.98 -0.24  0.24 -0.27]] This took 1207432.9853057861 miroseconds
</code></pre><p>Now it works! You might now be thinking, <em>wait a minute</em>, this was actually slower than before! Hold on a minute. The reason for this is that <code>numba</code> had to <em>compile</em> your function the first time you call it. This is where most of the time has gone in. In fact, if you now call <code>rapdf</code> again, you&rsquo;ll see:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>t1 <span style=color:#f92672>=</span> time()
scores <span style=color:#f92672>=</span> rapdf(df<span style=color:#f92672>.</span>values)
t2 <span style=color:#f92672>=</span> time()

<span style=color:#66d9ef>print</span>(scores, <span style=color:#e6db74>&#34;This took {} miroseconds&#34;</span><span style=color:#f92672>.</span>format((t2<span style=color:#f92672>-</span>t1)<span style=color:#f92672>*</span>(<span style=color:#ae81ff>10</span><span style=color:#f92672>**</span><span style=color:#ae81ff>6</span>)))
</code></pre></div><pre><code>[[-0.07 -0.23  0.65 -0.82  0.2  10.55]
 [-0.84 -0.19  0.    0.73 10.55  0.  ]
 [-0.52  0.64  1.3  10.55 -0.54 -0.65]
 ...
 [10.73  0.48 -0.4  -0.62 -0.59  1.54]
 [-0.14  1.71 -0.27 -0.49 -0.57 10.88]
 [-0.14 -0.08  0.98 -0.24  0.24 -0.27]] This took 232.93495178222656 miroseconds
</code></pre><p>And if we do this over several runs:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#f92672>%</span>timeit rapdf(df<span style=color:#f92672>.</span>values)
</code></pre></div><pre><code>28.1 µs ± 341 ns per loop (mean ± std. dev. of 7 runs, 10000 loops each)
</code></pre><p>Now look at that! It&rsquo;s shrunk down to 28 <em>microseconds</em> in comparison to the >7 <em>miliseconds</em> we had before. That&rsquo;s equivalent to a 250-fold speed up. You can imagine that if you had code that you&rsquo;d call over and over again, this is where <code>numba</code> could be so useful.</p></div><footer class=post-footer></footer></article></main><footer class=footer><span>&copy; 2021 <a href>Read between the rows</a></span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script defer src=/assets/js/highlight.min.27cd435cc9ed6abb4b496581b151804f79f366c412620272bb94e2f5f598ebcc.js integrity="sha256-J81DXMntartLSWWBsVGAT3nzZsQSYgJyu5Ti9fWY68w=" onload=hljs.initHighlightingOnLoad();></script><script>window.onload=function(){if(localStorage.getItem("menu-scroll-position")){document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position");}}
document.querySelectorAll('a[href^="#"]').forEach(anchor=>{anchor.addEventListener("click",function(e){e.preventDefault();var id=this.getAttribute("href").substr(1);if(!window.matchMedia('(prefers-reduced-motion: reduce)').matches){document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({behavior:"smooth"});}else{document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();}
if(id==="top"){history.replaceState(null,null," ");}else{history.pushState(null,null,`#${id}`);}});});var mybutton=document.getElementById("top-link");window.onscroll=function(){if(document.body.scrollTop>800||document.documentElement.scrollTop>800){mybutton.style.visibility="visible";mybutton.style.opacity="1";}else{mybutton.style.visibility="hidden";mybutton.style.opacity="0";}};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft);}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{if(document.body.className.includes("dark")){document.body.classList.remove('dark');localStorage.setItem("pref-theme",'light');}else{document.body.classList.add('dark');localStorage.setItem("pref-theme",'dark');}})</script></body></html>